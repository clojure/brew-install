#!/usr/bin/env bash
set -euo pipefail && cd "$(dirname "${BASH_SOURCE[0]}")/.."

# Unquotes the first argument passed, building up an array
#
# Arguments are separated by newlines. A newline can appear quoted.
#
# Backslashes need to be escape as \\
#
# Results are written to global array `args'
#

function unquote() {
    s="$1"

    # Remove trailing newline

    if [[ "${s:$((${#s}-1)):1}" == $'\n' ]]; then
        s=${s:0:${#s}-1}
    fi

    args=()
    arg=""

    for (( i=0; i<${#s}; i++ )); do
        c="${s:$i:1}"

        if [[ "$c" == $'\n' ]]; then
            args+=("$arg")
            arg=""
        elif [[ "$c" == "\\" ]]; then
            i=$((i + 1))
            c="${s:$i:1}"
            arg="${arg}${c}"
        else
            arg="${arg}${c}"
        fi
    done

    args+=("$arg")
}

function dump() {
    python -c "import sys, json; sys.stdout.write(json.dumps(sys.argv[1:]))" "$@"
}

function check() {
    actual="$(dump ${args[@]+"${args[@]}"})"
    if [[ "$actual" != "$expected" ]]; then
        echo "Assertion failed"
        printf "actual:   %s\n" "$actual"
        printf "expected: %s\n" "$expected"
        exit 1
    else
        echo "Ok"
    fi
}

unquote $'foo bar'
expected='["foo bar"]'
check

unquote $'foo\nbar'
expected='["foo", "bar"]'
check

unquote $'foo\nbar\n'
expected='["foo", "bar"]'
check

unquote $'foo\nbar '
expected='["foo", "bar "]'
check

unquote $'-co\n{:aot-cache true}'
expected='["-co", "{:aot-cache true}"]'
check

unquote $''
expected='[]'
check

unquote $'\nfoo'
expected='["foo"]'
check

unquote $'\nfoo\n\nbar'
expected='["foo"]'
check
